// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package mangapb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion9

// MangaServiceClient is the client API for MangaService service.
type MangaServiceClient interface {
	ListManga(ctx context.Context, in *ListMangaRequest, opts ...grpc.CallOption) (*ListMangaResponse, error)
	GetManga(ctx context.Context, in *GetMangaRequest, opts ...grpc.CallOption) (*GetMangaResponse, error)
}

type mangaServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMangaServiceClient(cc grpc.ClientConnInterface) MangaServiceClient {
	return &mangaServiceClient{cc}
}

func (c *mangaServiceClient) ListManga(ctx context.Context, in *ListMangaRequest, opts ...grpc.CallOption) (*ListMangaResponse, error) {
	out := new(ListMangaResponse)
	err := c.cc.Invoke(ctx, "/mangahub.v1.MangaService/ListManga", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mangaServiceClient) GetManga(ctx context.Context, in *GetMangaRequest, opts ...grpc.CallOption) (*GetMangaResponse, error) {
	out := new(GetMangaResponse)
	err := c.cc.Invoke(ctx, "/mangahub.v1.MangaService/GetManga", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MangaServiceServer is the server API for MangaService service.
type MangaServiceServer interface {
	ListManga(context.Context, *ListMangaRequest) (*ListMangaResponse, error)
	GetManga(context.Context, *GetMangaRequest) (*GetMangaResponse, error)
	mustEmbedUnimplementedMangaServiceServer()
}

// UnimplementedMangaServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMangaServiceServer struct{}

func (UnimplementedMangaServiceServer) ListManga(context.Context, *ListMangaRequest) (*ListMangaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListManga not implemented")
}

func (UnimplementedMangaServiceServer) GetManga(context.Context, *GetMangaRequest) (*GetMangaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetManga not implemented")
}

func (UnimplementedMangaServiceServer) mustEmbedUnimplementedMangaServiceServer() {}

// UnsafeMangaServiceServer may be embedded to opt out of forward compatibility for this service.
type UnsafeMangaServiceServer interface {
	mustEmbedUnimplementedMangaServiceServer()
}

func RegisterMangaServiceServer(s grpc.ServiceRegistrar, srv MangaServiceServer) {
	s.RegisterService(&MangaService_ServiceDesc, srv)
}

func _MangaService_ListManga_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMangaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MangaServiceServer).ListManga(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mangahub.v1.MangaService/ListManga",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MangaServiceServer).ListManga(ctx, req.(*ListMangaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MangaService_GetManga_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMangaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MangaServiceServer).GetManga(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mangahub.v1.MangaService/GetManga",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MangaServiceServer).GetManga(ctx, req.(*GetMangaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MangaService_ServiceDesc is the grpc.ServiceDesc for MangaService service.
var MangaService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mangahub.v1.MangaService",
	HandlerType: (*MangaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListManga",
			Handler:    _MangaService_ListManga_Handler,
		},
		{
			MethodName: "GetManga",
			Handler:    _MangaService_GetManga_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/manga.proto",
}

// ProgressServiceClient is the client API for ProgressService service.
type ProgressServiceClient interface {
	ListProgress(ctx context.Context, in *ListProgressRequest, opts ...grpc.CallOption) (*ListProgressResponse, error)
	GetProgress(ctx context.Context, in *GetProgressRequest, opts ...grpc.CallOption) (*GetProgressResponse, error)
	UpsertProgress(ctx context.Context, in *UpsertProgressRequest, opts ...grpc.CallOption) (*UpsertProgressResponse, error)
	DeleteProgress(ctx context.Context, in *DeleteProgressRequest, opts ...grpc.CallOption) (*DeleteProgressResponse, error)
}

type progressServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProgressServiceClient(cc grpc.ClientConnInterface) ProgressServiceClient {
	return &progressServiceClient{cc}
}

func (c *progressServiceClient) ListProgress(ctx context.Context, in *ListProgressRequest, opts ...grpc.CallOption) (*ListProgressResponse, error) {
	out := new(ListProgressResponse)
	err := c.cc.Invoke(ctx, "/mangahub.v1.ProgressService/ListProgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *progressServiceClient) GetProgress(ctx context.Context, in *GetProgressRequest, opts ...grpc.CallOption) (*GetProgressResponse, error) {
	out := new(GetProgressResponse)
	err := c.cc.Invoke(ctx, "/mangahub.v1.ProgressService/GetProgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *progressServiceClient) UpsertProgress(ctx context.Context, in *UpsertProgressRequest, opts ...grpc.CallOption) (*UpsertProgressResponse, error) {
	out := new(UpsertProgressResponse)
	err := c.cc.Invoke(ctx, "/mangahub.v1.ProgressService/UpsertProgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *progressServiceClient) DeleteProgress(ctx context.Context, in *DeleteProgressRequest, opts ...grpc.CallOption) (*DeleteProgressResponse, error) {
	out := new(DeleteProgressResponse)
	err := c.cc.Invoke(ctx, "/mangahub.v1.ProgressService/DeleteProgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProgressServiceServer is the server API for ProgressService service.
type ProgressServiceServer interface {
	ListProgress(context.Context, *ListProgressRequest) (*ListProgressResponse, error)
	GetProgress(context.Context, *GetProgressRequest) (*GetProgressResponse, error)
	UpsertProgress(context.Context, *UpsertProgressRequest) (*UpsertProgressResponse, error)
	DeleteProgress(context.Context, *DeleteProgressRequest) (*DeleteProgressResponse, error)
	mustEmbedUnimplementedProgressServiceServer()
}

// UnimplementedProgressServiceServer must be embedded to have forward compatible implementations.
type UnimplementedProgressServiceServer struct{}

func (UnimplementedProgressServiceServer) ListProgress(context.Context, *ListProgressRequest) (*ListProgressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProgress not implemented")
}

func (UnimplementedProgressServiceServer) GetProgress(context.Context, *GetProgressRequest) (*GetProgressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProgress not implemented")
}

func (UnimplementedProgressServiceServer) UpsertProgress(context.Context, *UpsertProgressRequest) (*UpsertProgressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertProgress not implemented")
}

func (UnimplementedProgressServiceServer) DeleteProgress(context.Context, *DeleteProgressRequest) (*DeleteProgressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProgress not implemented")
}

func (UnimplementedProgressServiceServer) mustEmbedUnimplementedProgressServiceServer() {}

// UnsafeProgressServiceServer may be embedded to opt out of forward compatibility for this service.
type UnsafeProgressServiceServer interface {
	mustEmbedUnimplementedProgressServiceServer()
}

func RegisterProgressServiceServer(s grpc.ServiceRegistrar, srv ProgressServiceServer) {
	s.RegisterService(&ProgressService_ServiceDesc, srv)
}

func _ProgressService_ListProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgressServiceServer).ListProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mangahub.v1.ProgressService/ListProgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgressServiceServer).ListProgress(ctx, req.(*ListProgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProgressService_GetProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgressServiceServer).GetProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mangahub.v1.ProgressService/GetProgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgressServiceServer).GetProgress(ctx, req.(*GetProgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProgressService_UpsertProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertProgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgressServiceServer).UpsertProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mangahub.v1.ProgressService/UpsertProgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgressServiceServer).UpsertProgress(ctx, req.(*UpsertProgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProgressService_DeleteProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgressServiceServer).DeleteProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mangahub.v1.ProgressService/DeleteProgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgressServiceServer).DeleteProgress(ctx, req.(*DeleteProgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProgressService_ServiceDesc is the grpc.ServiceDesc for ProgressService service.
var ProgressService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mangahub.v1.ProgressService",
	HandlerType: (*ProgressServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListProgress",
			Handler:    _ProgressService_ListProgress_Handler,
		},
		{
			MethodName: "GetProgress",
			Handler:    _ProgressService_GetProgress_Handler,
		},
		{
			MethodName: "UpsertProgress",
			Handler:    _ProgressService_UpsertProgress_Handler,
		},
		{
			MethodName: "DeleteProgress",
			Handler:    _ProgressService_DeleteProgress_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/manga.proto",
}
